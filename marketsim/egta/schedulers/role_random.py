import random
import numpy as np
from typing import List, Optional, Set, Tuple, Any
from collections import Counter

from marketsim.egta.schedulers.base import Scheduler
from marketsim.egta.core.game import Game


class RoleRandomScheduler(Scheduler):
    """
    A scheduler that generates random profiles for Role-Symmetric Games.
    It ensures that the number of players in each role is respected and
    assigns strategies within those roles randomly.
    It avoids generating duplicate profiles it has previously generated.
    """
    def __init__(self,
                 role_names: List[str],
                 num_players_per_role: List[int],
                 strategy_names_per_role: List[List[str]],
                 batch_size: int = 10,
                 seed: Optional[int] = None):
        """
        Initialize the RoleRandomScheduler.
        Args:
            role_names: List of role names.
            num_players_per_role: List of player counts for each role.
            strategy_names_per_role: List of lists of strategy names for each role.
            batch_size: Number of profiles to generate in each batch.
            seed: Random seed.
        """
        self.batch_size = batch_size
        self.seed = seed

        if not (len(role_names) == len(num_players_per_role) == len(strategy_names_per_role)):
            raise ValueError("Mismatch in lengths of role_names, num_players_per_role, and strategy_names_per_role")

        self.role_names: List[str] = role_names
        self.num_players_per_role: List[int] = num_players_per_role
        self.strategy_names_per_role: List[List[str]] = strategy_names_per_role
        
        self.num_roles: int = len(role_names)
        self.np_num_strategies_per_role: np.ndarray = np.array([len(s) for s in strategy_names_per_role], dtype=int)
        if np.any(self.np_num_strategies_per_role == 0) and sum(self.num_players_per_role) > 0:
           
            role_with_no_strats_and_players = False
            for r_idx in range(self.num_roles):
                if self.np_num_strategies_per_role[r_idx] == 0 and self.num_players_per_role[r_idx] > 0:
                    role_with_no_strats_and_players = True
                    break
            if role_with_no_strats_and_players:
                raise ValueError("Each role with players must have at least one strategy.")

        self.total_num_players = sum(self.num_players_per_role)
        # Stores frozenset(Counter(profile_list).items()) to track unique profiles generated by this scheduler instance.
        self.generated_profiles_summary_set: Set[frozenset[Tuple[Any, int]]] = set()

        if self.seed is not None:
            random.seed(self.seed)
            np.random.seed(self.seed) 

    def get_next_batch(self, 
                       game: Optional[Game] = None, # game might be used in future to get total unique profiles if known
                       num_profiles: Optional[int] = None
                       ) -> List[List[str]]:
        """
        Generate a batch of random profiles for the Role-Symmetric Game.
        Avoids re-generating profiles previously generated by this instance.
        """
        num_to_sample = num_profiles if num_profiles is not None else self.batch_size
        generated_profiles_this_batch: List[List[str]] = []
        
        attempts = 0
        max_attempts_multiplier = 200 # Increased multiplier for smaller strategy spaces
        max_total_attempts = num_to_sample * max_attempts_multiplier

        while len(generated_profiles_this_batch) < num_to_sample and attempts < max_total_attempts:
            current_full_profile_flat: List[str] = []
            for r_idx in range(self.num_roles):
                role_name = self.role_names[r_idx]
                num_players_in_this_role = self.num_players_per_role[r_idx]
                strategies_for_this_role = self.strategy_names_per_role[r_idx]

                if num_players_in_this_role == 0:
                    continue 
                if not strategies_for_this_role and num_players_in_this_role > 0:
                    # This case should be caught by __init__ validation
                    raise ValueError(f"Role '{role_name}' has players but no strategies defined.")

                player_assignments_in_role = random.choices(strategies_for_this_role, k=num_players_in_this_role)
                
                for s_name in player_assignments_in_role:
                    current_full_profile_flat.append(f"{role_name}_{s_name}")
            
            profile_summary_for_set = frozenset(Counter(current_full_profile_flat).items())

            if profile_summary_for_set not in self.generated_profiles_summary_set:
                # Check if it's a duplicate *within the current batch being constructed*
                # This check is actually redundant if adding to generated_profiles_summary_set immediately.
                # For robustness if we were to add to set only at end of batch:
                # is_new_to_this_batch = True
                # for existing_prof_list in generated_profiles_this_batch:
                #     if Counter(existing_prof_list) == Counter(current_full_profile_flat):
                #         is_new_to_this_batch = False
                #         break
                # if is_new_to_this_batch:
                generated_profiles_this_batch.append(current_full_profile_flat)
                self.generated_profiles_summary_set.add(profile_summary_for_set) # Add to historical set
            attempts += 1
        
        if len(generated_profiles_this_batch) < num_to_sample and attempts >= max_total_attempts:
            print(f"Warning: RoleRandomScheduler could only generate {len(generated_profiles_this_batch)} unique profiles "
                  f"out of {num_to_sample} requested after {max_total_attempts} attempts. "
                  f"The unique strategy profile space might be small or largely exhausted by this scheduler instance.")

        return generated_profiles_this_batch

    def update(self, game: Game):
        """
        Allows EGTA to inform the scheduler about all profiles simulated so far, 
        so the scheduler can avoid re-sampling them in subsequent calls to get_next_batch.
        This assumes EGTA maintains a set of canonical profile representations.
        """
        # The `game` object from EGTA.py doesn't directly store the `simulated_profiles` set from EGTA.
        # EGTA.py would need to be modified to pass its `self.simulated_profiles` set here.
        # Or, this scheduler can attempt to infer from game.payoff_data, but that's less direct.
        # For now, this method will be a pass, as the primary duplicate avoidance is internal 
        # to the scheduler's lifetime via self.generated_profiles_summary_set.
        # If EGTA is modified to pass its master set of simulated profiles (e.g. via game.metadata or a direct call),
        # this method could merge that set into self.generated_profiles_summary_set.
        pass